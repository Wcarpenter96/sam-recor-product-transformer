from typing import Dict, List, Optional

import boto3
from botocore.exceptions import ClientError


class DynamoDBService:
    """Encapsulates interactions with DynamoDB."""

    def __init__(self, region_name: str = "us-east-1"):
        """
        Initializes the DynamoDBService.

        Args:
            region_name: The AWS region name. Defaults to 'us-east-1'.
        """
        self.dynamodb = boto3.resource("dynamodb", region_name=region_name)
        self.item_id_table = self.dynamodb.Table("iml-item-id-table")
        self.category_id_table = self.dynamodb.Table("iml-category-id-table")

    def get_batch_items(self, table_name: str, keys: List[Dict]) -> List[Dict]:
        """
        Retrieves multiple items from a DynamoDB table in a batch.

        Args:
            table_name: The name of the DynamoDB table.
            keys: A list of dictionaries, where each dictionary represents the key
                  of an item to retrieve.  For example: `[{"id": "1"}, {"id": "2"}]`

        Returns:
            A list of dictionaries, where each dictionary represents a retrieved item.
        Raises:
            ClientError: If an error occurs during the DynamoDB operation.
        """
        try:
            response = self.dynamodb.batch_get_item(
                RequestItems={table_name: {"Keys": keys}}
            )
            return response.get("Responses", {}).get(table_name, [])
        except ClientError as e:
            print(f"Error retrieving batch items from DynamoDB table '{table_name}': {e}")
            raise  # Re-raise the ClientError

    def put_batch_items(self, table_name: str, items: List[Dict]) -> None:
        """
        Writes multiple items to a DynamoDB table in a batch.

        Args:
            table_name: The name of the DynamoDB table.
            items: A list of dictionaries, where each dictionary represents an item
                   to write to the table.
        Raises:
            ClientError: If an error occurs during the DynamoDB operation.
        """
        table = self.dynamodb.Table(table_name)
        with table.batch_writer() as writer:
            for item in items:
                try:
                    writer.put_item(Item=item)
                    print(f"SUCCESS: Wrote item to DynamoDB table '{table_name}': {item}")
                except ClientError as e:
                    print(
                        f"Error writing item to DynamoDB table '{table_name}': {e}. Item: {item}"
                    )
                    raise  # Re-raise the ClientError

    def get_item(self, table_name: str, key: Dict) -> Optional[Dict]:
        """
        Retrieves a single item from a DynamoDB table.

        Args:
            table_name: The name of the DynamoDB table.
            key: A dictionary representing the primary key of the item to retrieve.
                   For example, `{"id": "some-id"}`

        Returns:
            A dictionary representing the retrieved item, or None if the item is not found.
        Raises:
            ClientError: If an error occurs during the DynamoDB operation.
        """
        table = self.dynamodb.Table(table_name)
        try:
            response = table.get_item(Key=key)
            return response.get("Item")  # Returns None if Item doesn't exist
        except ClientError as e:
            print(f"Error retrieving item from DynamoDB table '{table_name}': {e}")
            raise  # Re-raise the ClientError

    def put_item(self, table_name: str, item: Dict) -> None:
        """
        Writes a single item to a DynamoDB table.

        Args:
            table_name: The name of the DynamoDB table.
            item: A dictionary representing the item to write to the table.
         Raises:
            ClientError: If an error occurs during the DynamoDB operation.
        """
        table = self.dynamodb.Table(table_name)
        try:
            table.put_item(Item=item)
            print(f"SUCCESS: Wrote item to DynamoDB table '{table_name}': {item}")
        except ClientError as e:
            print(f"Error writing item to DynamoDB table '{table_name}': {e}")
            raise  # Re-raise the ClientError

    def get_all_dynamodb_items(self, table_name: str):
        """
        Fetches all items from a given DynamoDB table.

        Args:
            table_name (str): The name of the DynamoDB table.

        Returns:
            list: A list of dictionaries, where each dictionary represents an item.
                  Returns an empty list if no items are found or on error.
        """
        table = self.dynamodb.Table(table_name)

        items = []
        response = None

        try:
            while True:
                if response:
                    # If there's a LastEvaluatedKey from the previous scan,
                    # use it to continue scanning from where we left off.
                    response = table.scan(ExclusiveStartKey=response.get('LastEvaluatedKey'))
                else:
                    # First scan operation
                    response = table.scan()

                items.extend(response.get('Items', []))

                # If LastEvaluatedKey is not present, it means we've retrieved all items
                if 'LastEvaluatedKey' not in response:
                    break
        except ClientError as e:
            print(f"Error fetching items from DynamoDB: {e}")
            # Optionally, you can log the full error or re-raise it
            # raise e
        except Exception as e:
            print(f"An unexpected error occurred: {e}")

        return items

    def delete_all_dynamodb_items(self, table_name: str):
        """
        Deletes all items from a given DynamoDB table.

        WARNING: This operation is highly destructive and will permanently remove
                 all data from the table. Use with extreme caution.

        Args:
            table_name (str): The name of the DynamoDB table.

        Returns:
            bool: True if the deletion process completed (even if some errors occurred
                  during batch writes), False if a critical error prevented the process
                  from starting or completing the initial scan.
        """
        table = self.dynamodb.Table(table_name)

        print(f"Attempting to delete all items from table: '{table_name}' in region '{self.region_name}'...")

        try:
            # Get the table's key schema to identify the primary key attributes
            # This is crucial because delete_item requires the full primary key
            key_schema = table.key_schema
            partition_key_name = None
            sort_key_name = None

            for key_attribute in key_schema:
                if key_attribute['KeyType'] == 'HASH':
                    partition_key_name = key_attribute['AttributeName']
                elif key_attribute['KeyType'] == 'RANGE':
                    sort_key_name = key_attribute['AttributeName']

            if not partition_key_name:
                print(f"Error: Could not determine partition key for table '{table_name}'. Aborting.")
                return False

            # Prepare ProjectionExpression to only retrieve primary keys
            projection_expression = partition_key_name
            if sort_key_name:
                projection_expression += f", {sort_key_name}"

            # Scan the table to get all primary keys for deletion
            items_to_delete_keys = []
            response = None

            print("Scanning table to collect primary keys for deletion...")
            while True:
                scan_params = {
                    'ProjectionExpression': projection_expression
                }
                if response and 'LastEvaluatedKey' in response:
                    scan_params['ExclusiveStartKey'] = response['LastEvaluatedKey']

                response = table.scan(**scan_params)

                for item in response.get('Items', []):
                    key = {partition_key_name: item[partition_key_name]}
                    if sort_key_name:
                        key[sort_key_name] = item[sort_key_name]
                    items_to_delete_keys.append(key)

                if 'LastEvaluatedKey' not in response:
                    break

            if not items_to_delete_keys:
                print(f"No items found in table '{table_name}' to delete.")
                return True

            print(f"Found {len(items_to_delete_keys)} items to delete.")
            print("Starting batch deletion process...")

            # Use batch_writer for efficient deletion
            # batch_writer handles sending items in batches of up to 25
            # and retries failed requests.
            with table.batch_writer() as batch:
                for key in items_to_delete_keys:
                    batch.delete_item(Key=key)

            print(f"Successfully initiated deletion for {len(items_to_delete_keys)} items.")
            print("Note: DynamoDB batch operations are eventually consistent. Deletion may take a moment to propagate.")
            return True

        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code")
            error_message = e.response.get("Error", {}).get("Message")
            print(f"DynamoDB Client Error: {error_code} - {error_message}")
            print(f"Could not delete items from table '{table_name}'.")
            return False
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            print(f"Could not delete items from table '{table_name}'.")
            return False
